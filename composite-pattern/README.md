# Composite Pattern

### Composite Pattern이란?
부분-전체 계층구조를 가진 객체 컬렉션에서 그 객체들을 모두 똑같은 방식으로 다루고 싶을 때 쓰이는 패턴

##### 복합객체 (Composite object)
- 다른 객체를 포함하고 있는 객체 ( child가 있음 )

##### 잎 객체 (Leaf object)
- 다른 객체를 포함하고 있지 않은 객체 ( child가 없음 )

#### 주요 특징
1. 객체들을 똑같이 다룬다. 다시말해 복합 객체와 잎 객체에 똑같은 메소드를 호출한다. 즉, 모든 객체의 인터페이스가 같아야한다는 말이 된다.
2. 트리 구조를 이루고 있다. 뿌리는 최상위 복합 객체, 자식들은 모두 복합 객체나 잎으로 이루어져 있다.
3. Decorator adds additional responsibilities to the wrapped object, while Composite just “sums up” its children’s results. 왜 이 말이 이해가 안되지... 왜 sum up 해? - decorator는 금액을 반환할 때 object의 price + 자신의 price를 return 시키므로 responsibility가 추가되지만, composite 패턴은 자기 자신의 금액만을 return 시킨다는 말!

#### 장점
1. 클라이언트를 단순화할 수 있다. 클라이언트가 객체를 사용할 때 복합 객체를 사용하는지, 잎 객체를 사용하는지 신경 쓸 필요가 없다.
2. 가장 큰 장점은 트리 안에 존재하는 모든 객체를 생성하게 사용할 필요가 없다는 점이다.
3. 클라이언트는 객체가 복합 객체인지 잎 객체인지 알 필요도 없고, 모두 하나의 인터페이스로 다루면 된다.

#### 단점
1. `클라이언트가 어떤 형식의 객체를 다루는지 알 수가 없다. 따라서 객체의 메소드를 호출하기 위해서는 객체의 형식을 매번 확인해야 한다.`: 이걸 어떻게 보완할 수 있지? 클라이언트가 digging을 할 때 매번 객체의 형식을 확인하고 메소드를 달리 호출해야 한다.
   1. interface에 isComposite 메소드를 두고, 복합 객체인지 잎 객체인지 확인할 수 있도록 보완 할 수 있다.
2. common interface를 제공하는게 매우 어렵다. 해당 interface는 계속해서 메소드가 만들어질거고, 가면 갈수록 interface를 이해하기 어려워진다.

### 복잡한 구조도 쉽게 풀어낼 수 있나?
- component interface 내에 브랜드(현대, 기아 등등)와 차(아반떼, 그랜저 등등)의 메소드가 모두 구현되어 있어야 한다. 그럼 composite를 써야돼...? 다른 패턴을 어떤걸 생각해볼 수 있을까?
- 차라리 브랜드 interface, car interface를 따로 두고 만들어내는게 더 나을거 같은데..
1. 차
   1. 현대
      1. 기아
         1. 소렌토
         2. 니로
      2. 아반떼
      3. 그랜저
   3. BMW
      1. 벤틀리
         1. 플라잉스퍼
      2. 미니
         1. 컨트리맨
      3. 3시리즈
      4. 5시리즈

### 구현체 간단 설명
`MenuComponent`: Menu와 MenuItem 모두에게 적용되는 인터페이스
기본적으로 메소드 내부적으로 throw Error. 추상 클래스를 extends 하는 클래스는
특정 메소드를 사용하려고 하면 무조건 클래스 내에 선언해야 한다.

Composite Pattern은 한 클래스에 2가지의 역할을 넣고 있다는 점에서 단일 역할 원칙을 깨지만, 그 대신 투명성을 확보하는 패턴이라고 할 수 있다.
여기서 `투명성(transparency)`이란 어떤 원소가 복합 객체인지 잎인지 클라이언트에게는 투명하게 보인다는 점이다. 클라이언트가 복합 객체와 잎을 똑같은 방식으로 처리할 수 있기 때문에.

